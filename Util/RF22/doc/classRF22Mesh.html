<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RF22: RF22Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RF22Mesh Class Reference</h1><!-- doxytag: class="RF22Mesh" --><!-- doxytag: inherits="RF22Router" -->
<p><a class="el" href="classRF22.html" title="Send and receive unaddressed, unreliable datagrams.">RF22</a> subclass for sending addressed, optionally acknowledged datagrams multi-hop routed across a network, with automatic route discovery.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RF22Mesh_8h_source.html">RF22Mesh.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RF22Mesh:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRF22Mesh.png" usemap="#RF22Mesh_map" alt=""/>
  <map id="RF22Mesh_map" name="RF22Mesh_map">
<area href="classRF22Router.html" alt="RF22Router" shape="rect" coords="0,168,141,192"/>
<area href="classRF22ReliableDatagram.html" alt="RF22ReliableDatagram" shape="rect" coords="0,112,141,136"/>
<area href="classRF22Datagram.html" alt="RF22Datagram" shape="rect" coords="0,56,141,80"/>
<area href="classRF22.html" alt="RF22" shape="rect" coords="0,0,141,24"/>
</map>
 </div>
</div>

<p><a href="classRF22Mesh-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRF22Mesh_1_1MeshApplicationMessage.html">MeshApplicationMessage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signals an application layer message for the caller of <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a>.  <a href="structRF22Mesh_1_1MeshApplicationMessage.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRF22Mesh_1_1MeshMessageHeader.html">MeshMessageHeader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of the basic <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a> header.  <a href="structRF22Mesh_1_1MeshMessageHeader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRF22Mesh_1_1MeshRouteDiscoveryMessage.html">MeshRouteDiscoveryMessage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRF22Mesh_1_1MeshRouteFailureMessage.html">MeshRouteFailureMessage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signals a route failure.  <a href="structRF22Mesh_1_1MeshRouteFailureMessage.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#acfabd46c192bd547460b9b86e0f68607">RF22Mesh</a> (uint8_t thisAddress=0, uint8_t slaveSelectPin=10, uint8_t interrupt=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#ada9dcba842569c7f126fdb1d085753a5">sendtoWait</a> (uint8_t *buf, uint8_t len, uint8_t dest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#a5702996188d7b3941a844fc4d39a6f57">recvfromAck</a> (uint8_t *buf, uint8_t *len, uint8_t *source=NULL, uint8_t *dest=NULL, uint8_t *id=NULL, uint8_t *flags=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#a09ff3e2f1481180881ead85c069fe547">recvfromAckTimeout</a> (uint8_t *buf, uint8_t *len, uint16_t timeout, uint8_t *source=NULL, uint8_t *dest=NULL, uint8_t *id=NULL, uint8_t *flags=NULL)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#a340dba041b6d8e83a6ce6a4f613eb112">peekAtMessage</a> (<a class="el" href="structRF22Router_1_1RoutedMessage.html">RoutedMessage</a> *message, uint8_t messageLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#ae7a3ab2784aaf45ab2d47e5d9ce5b405">route</a> (<a class="el" href="structRF22Router_1_1RoutedMessage.html">RoutedMessage</a> *message, uint8_t messageLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#a276fbdde9038cb38e3ba2d6cffa95a4c">doArp</a> (uint8_t address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF22Mesh.html#aa619f98b3156358bcb0258ab1f50f46d">isPhysicalAddress</a> (uint8_t *address, uint8_t addresslen)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classRF22.html" title="Send and receive unaddressed, unreliable datagrams.">RF22</a> subclass for sending addressed, optionally acknowledged datagrams multi-hop routed across a network, with automatic route discovery. </p>
<p>Extends <a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a> to add automatic route discovery within a mesh of adjacent nodes, and route signalling.</p>
<p>Unlike <a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a>, <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a> can be used in networks where the network topology is fluid, or unknown, or if nodes can mode around or go in or out of service. When a node wants to send a message to another node, it will automcatically discover a route to the destaintion node and use it. If the route becomes unavailable, a new route will be discovered.</p>
<dl class="user"><dt><b>Route Discovery</b></dt><dd></dd></dl>
<p>When a <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a> mesh node is initialised, it doe not know any routes to any other nodes (see <a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a> for details on route and the routing table). When you attempt to send a message with sendtoWait, will first check to see if there is a route to the destinastion node in the routing tabl;e. If not, it wil initialite 'Route Discovery'. When a node needs to discover a route to another node, it broadcasts <a class="el" href="structRF22Mesh_1_1MeshRouteDiscoveryMessage.html">MeshRouteDiscoveryMessage</a> with a message type of RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_REQUEST. Any node that receives such a request checks to see if it is a request for a route to itself (in which case it makes a unicast reply to the originating node with a <a class="el" href="structRF22Mesh_1_1MeshRouteDiscoveryMessage.html">MeshRouteDiscoveryMessage</a> with a message type of RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_RESPONSE) otherwise it rebroadcasts the request, after adding itself to the list of nodes visited so far by the request.</p>
<p>If a node receives a RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_REQUEST that already has itself listed in the visited nodes, it knows it has already seen and rebroadcast this request, and threfore ignores it. This prevents broadcast storms. When a node receives a RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_REQUEST it can use the list of nodes aready visited to deduce routes back towards the originating (requesting node). This also means that when the destination node of the request is reached, it (and all the previous nodes the request visited) will have a route back to the originating node. This means the unicast RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_RESPONSE reply will be routed successfully back to the original route requester.</p>
<p>The RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_RESPONSE sent back by the destination node contains the full list of nodes that were visited on the way to the destination. Therefore, intermediate nodes that route the reply back towards the originating node can use the node list in the reply to deduce routes to all the nodes between it and the destination node.</p>
<p>Therefore, RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_REQUEST and RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_RESPONSE together ensure the original requester and all the intermediate nodes know how to route to the source and destination nodes and every node along the path.</p>
<p>Note that there is a race condition here that can effect routing on multipath routes. For example, if the route to the destination can traverse several paths, last reply from the destination will be the one used.</p>
<dl class="user"><dt><b>Route Failure</b></dt><dd></dd></dl>
<p><a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a> (and therefore <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a>) use reliable hop-to-hop delivery of messages using hop-to-hop acknowledgements, but not end-to-end acknowledgements. When <a class="el" href="classRF22Mesh.html#ada9dcba842569c7f126fdb1d085753a5">sendtoWait()</a> returns, you know that the message has been delivered to the next hop, but not if it is (or even if it can be) delivered to the destination node. If during the course of hop-to-hop routing of a message, one of the intermediate <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a> nodes finds it cannot deliver to the next hop (say due to a lost route or no acknwledgement from the next hop), it replies to the originator with a unicast <a class="el" href="structRF22Mesh_1_1MeshRouteFailureMessage.html" title="Signals a route failure.">MeshRouteFailureMessage</a> RF22_MESH_MESSAGE_TYPE_ROUTE_FAILURE message. Intermediate nodes (on the way beack to the originator) and the originating node use this message to delete the route to the destination node of the original message. This means that if a route to a destination becomes unusable (either because an intermediate node is off the air, or has moved out of range) a new route will be established the next time a message is to be sent.</p>
<dl class="user"><dt><b>Message Format</b></dt><dd></dd></dl>
<p><a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a> uses a number of message formats layered on top of <a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a>:</p>
<ul>
<li><a class="el" href="structRF22Mesh_1_1MeshApplicationMessage.html" title="Signals an application layer message for the caller of RF22Mesh.">MeshApplicationMessage</a> (message type RF22_MESH_MESSAGE_TYPE_APPLICATION). Carries an application layer message for the caller of <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a></li>
<li><a class="el" href="structRF22Mesh_1_1MeshRouteDiscoveryMessage.html">MeshRouteDiscoveryMessage</a> (message types RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_REQUEST and RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_RESPONSE). Carries Route Discovery messages (broadcast) and replies (unicast).</li>
<li><a class="el" href="structRF22Mesh_1_1MeshRouteFailureMessage.html" title="Signals a route failure.">MeshRouteFailureMessage</a> (message type RF22_MESH_MESSAGE_TYPE_ROUTE_FAILURE) Informs nodes of route failures.</li>
</ul>
<p>Part of the Arduino <a class="el" href="classRF22.html" title="Send and receive unaddressed, unreliable datagrams.">RF22</a> library for operating with HopeRF <a class="el" href="classRF22.html" title="Send and receive unaddressed, unreliable datagrams.">RF22</a> compatible transceivers (see <a href="http://www.hoperf.com">http://www.hoperf.com</a>) </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acfabd46c192bd547460b9b86e0f68607"></a><!-- doxytag: member="RF22Mesh::RF22Mesh" ref="acfabd46c192bd547460b9b86e0f68607" args="(uint8_t thisAddress=0, uint8_t slaveSelectPin=10, uint8_t interrupt=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF22Mesh::RF22Mesh </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>thisAddress</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>slaveSelectPin</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>interrupt</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thisAddress</em>&nbsp;</td><td>The address to assign to this node. Defaults to 0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>slaveSelectPin</em>&nbsp;</td><td>the Arduino pin number of the output to use to select the <a class="el" href="classRF22.html" title="Send and receive unaddressed, unreliable datagrams.">RF22</a> before accessing it </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interrupt</em>&nbsp;</td><td>The interrupt number to use. Default is interrupt 0 (Arduino input pin 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a276fbdde9038cb38e3ba2d6cffa95a4c"></a><!-- doxytag: member="RF22Mesh::doArp" ref="a276fbdde9038cb38e3ba2d6cffa95a4c" args="(uint8_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF22Mesh::doArp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Try to resolve a route for the given address. Blocks while discovering the route which may take up to 4000 msec. Virtual so subclasses can override. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>The physical addres to resolve </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the address was resolved and added to the local routing table </dd></dl>

<p>References <a class="el" href="RF22Router_8cpp_source.html#l00045">RF22Router::addRouteTo()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00123">RF22Mesh::MeshRouteDiscoveryMessage::dest</a>, <a class="el" href="RF22Mesh_8h_source.html#l00122">RF22Mesh::MeshRouteDiscoveryMessage::destlen</a>, <a class="el" href="RF22Mesh_8h_source.html#l00121">RF22Mesh::MeshRouteDiscoveryMessage::header</a>, <a class="el" href="RF22_8cpp_source.html#l00695">RF22::headerFrom()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00107">RF22Mesh::MeshMessageHeader::msgType</a>, <a class="el" href="RF22Router_8cpp_source.html#l00205">RF22Router::recvfromAck()</a>, and <a class="el" href="RF22Mesh_8cpp_source.html#l00032">sendtoWait()</a>.</p>

<p>Referenced by <a class="el" href="RF22Mesh_8cpp_source.html#l00032">sendtoWait()</a>.</p>

</div>
</div>
<a class="anchor" id="aa619f98b3156358bcb0258ab1f50f46d"></a><!-- doxytag: member="RF22Mesh::isPhysicalAddress" ref="aa619f98b3156358bcb0258ab1f50f46d" args="(uint8_t *address, uint8_t addresslen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF22Mesh::isPhysicalAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>addresslen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tests if the given address of length addresslen is indentical to the physical addres of this node. <a class="el" href="classRF22Mesh.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Mesh</a> always ikmplements p[hysical addresses as the 1 octet address of the node given by _thisAddress Called by <a class="el" href="classRF22Mesh.html#a5702996188d7b3941a844fc4d39a6f57">recvfromAck()</a> to test whether a RF22_MESH_MESSAGE_TYPE_ROUTE_DISCOVERY_REQUEST is for this node. Subclasses may want to override to implemnt mode complicated or longer physical addresses </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>Address of the pyysical addres being tested </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addresslen</em>&nbsp;</td><td>Lengthof the address in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the physical address of this node is identical to address </dd></dl>

<p>References <a class="el" href="RF22Datagram_8h_source.html#l00072">RF22Datagram::_thisAddress</a>.</p>

<p>Referenced by <a class="el" href="RF22Mesh_8cpp_source.html#l00149">recvfromAck()</a>.</p>

</div>
</div>
<a class="anchor" id="a340dba041b6d8e83a6ce6a4f613eb112"></a><!-- doxytag: member="RF22Mesh::peekAtMessage" ref="a340dba041b6d8e83a6ce6a4f613eb112" args="(RoutedMessage *message, uint8_t messageLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF22Mesh::peekAtMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF22Router_1_1RoutedMessage.html">RoutedMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>messageLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Internal function that inspects messages being received and adjusts the routing table if necessary. Called by <a class="el" href="classRF22Mesh.html#a5702996188d7b3941a844fc4d39a6f57">recvfromAck()</a> immediately after it gets the message from <a class="el" href="classRF22ReliableDatagram.html" title="RF22 subclass for sending addressed, acknowledged, retransmitted datagrams.">RF22ReliableDatagram</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>Pointer to the <a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a> message that was received. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageLen</em>&nbsp;</td><td>Length of message in octets </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classRF22Router.html#a1ddc1e959c8851add1c78ee1b1af8b66">RF22Router</a>.</p>

<p>References <a class="el" href="RF22Datagram_8h_source.html#l00072">RF22Datagram::_thisAddress</a>, <a class="el" href="RF22Router_8cpp_source.html#l00045">RF22Router::addRouteTo()</a>, <a class="el" href="RF22Router_8h_source.html#l00152">RF22Router::RoutedMessage::data</a>, <a class="el" href="RF22Router_8cpp_source.html#l00125">RF22Router::deleteRouteTo()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00131">RF22Mesh::MeshRouteFailureMessage::dest</a>, <a class="el" href="RF22Mesh_8h_source.html#l00123">RF22Mesh::MeshRouteDiscoveryMessage::dest</a>, <a class="el" href="RF22_8cpp_source.html#l00695">RF22::headerFrom()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00107">RF22Mesh::MeshMessageHeader::msgType</a>, and <a class="el" href="RF22Mesh_8h_source.html#l00124">RF22Mesh::MeshRouteDiscoveryMessage::route</a>.</p>

</div>
</div>
<a class="anchor" id="a5702996188d7b3941a844fc4d39a6f57"></a><!-- doxytag: member="RF22Mesh::recvfromAck" ref="a5702996188d7b3941a844fc4d39a6f57" args="(uint8_t *buf, uint8_t *len, uint8_t *source=NULL, uint8_t *dest=NULL, uint8_t *id=NULL, uint8_t *flags=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF22Mesh::recvfromAck </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>source</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>dest</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>id</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts the receiver if it is not running already. If there is a valid application layer message available for this node (or RF22_BROADCAST_ADDRESS), send an acknowledgement to the last hop address (blocking until this is complete), then copy the application message payload data to buf and return true else return false. If a message is copied, *len is set to the length.. If from is not NULL, the originator SOURCE address is placed in *source. If to is not NULL, the DEST address is placed in *dest. This might be this nodes address or RF22_BROADCAST_ADDRESS. This is the preferred function for getting messages addressed to this node. If the message is not a broadcast, acknowledge to the sender before returning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Location to copy the received message </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Available space in buf. Set to the actual number of octets copied. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>source</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the SOURCE address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the DEST address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the ID </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the FLAGS (not just those addressed to this node). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a valid message was recvived for this node and copied to buf </dd></dl>

<p>Reimplemented from <a class="el" href="classRF22Router.html#abbb4344322693607d8a0be5f0f831015">RF22Router</a>.</p>

<p>References <a class="el" href="RF22Router_8h_source.html#l00313">RF22Router::_max_hops</a>, <a class="el" href="RF22Datagram_8h_source.html#l00072">RF22Datagram::_thisAddress</a>, <a class="el" href="RF22Router_8cpp_source.html#l00045">RF22Router::addRouteTo()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00114">RF22Mesh::MeshApplicationMessage::data</a>, <a class="el" href="RF22Mesh_8h_source.html#l00123">RF22Mesh::MeshRouteDiscoveryMessage::dest</a>, <a class="el" href="RF22Mesh_8h_source.html#l00122">RF22Mesh::MeshRouteDiscoveryMessage::destlen</a>, <a class="el" href="RF22Mesh_8h_source.html#l00121">RF22Mesh::MeshRouteDiscoveryMessage::header</a>, <a class="el" href="RF22_8cpp_source.html#l00695">RF22::headerFrom()</a>, <a class="el" href="RF22Mesh_8cpp_source.html#l00142">isPhysicalAddress()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00107">RF22Mesh::MeshMessageHeader::msgType</a>, <a class="el" href="RF22Router_8cpp_source.html#l00205">RF22Router::recvfromAck()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00124">RF22Mesh::MeshRouteDiscoveryMessage::route</a>, and <a class="el" href="RF22Mesh_8cpp_source.html#l00032">sendtoWait()</a>.</p>

<p>Referenced by <a class="el" href="RF22Mesh_8cpp_source.html#l00221">recvfromAckTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="a09ff3e2f1481180881ead85c069fe547"></a><!-- doxytag: member="RF22Mesh::recvfromAckTimeout" ref="a09ff3e2f1481180881ead85c069fe547" args="(uint8_t *buf, uint8_t *len, uint16_t timeout, uint8_t *source=NULL, uint8_t *dest=NULL, uint8_t *id=NULL, uint8_t *flags=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF22Mesh::recvfromAckTimeout </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>source</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>dest</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>id</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts the receiver if it is not running already. Similar to <a class="el" href="classRF22Mesh.html#a5702996188d7b3941a844fc4d39a6f57">recvfromAck()</a>, this will block until either a valid application layer message available for this node or the timeout expires. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Location to copy the received message </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Available space in buf. Set to the actual number of octets copied. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Maximum time to wait in milliseconds </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>source</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the SOURCE address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the DEST address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the ID </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>If present and not NULL, the referenced uint8_t will be set to the FLAGS (not just those addressed to this node). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a valid message was copied to buf </dd></dl>

<p>Reimplemented from <a class="el" href="classRF22Router.html#af4f975c229288c480e13de4e6ddea8fb">RF22Router</a>.</p>

<p>References <a class="el" href="RF22Mesh_8cpp_source.html#l00149">recvfromAck()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7a3ab2784aaf45ab2d47e5d9ce5b405"></a><!-- doxytag: member="RF22Mesh::route" ref="ae7a3ab2784aaf45ab2d47e5d9ce5b405" args="(RoutedMessage *message, uint8_t messageLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF22Mesh::route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRF22Router_1_1RoutedMessage.html">RoutedMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>messageLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Internal function that inspects messages being received and adjusts the routing table if necessary. This is virtual, which lets subclasses override or intercept the <a class="el" href="classRF22Mesh.html#ae7a3ab2784aaf45ab2d47e5d9ce5b405">route()</a> function. Called by sendtoWait after the message header has been filled in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>Pointer to the <a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a> message to be sent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageLen</em>&nbsp;</td><td>Length of message in octets </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classRF22Router.html#a76edfc892808e5b8c1d54f69ba2d8ebd">RF22Router</a>.</p>

<p>References <a class="el" href="RF22Datagram_8h_source.html#l00072">RF22Datagram::_thisAddress</a>, <a class="el" href="RF22Router_8cpp_source.html#l00045">RF22Router::addRouteTo()</a>, <a class="el" href="RF22Router_8cpp_source.html#l00125">RF22Router::deleteRouteTo()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00131">RF22Mesh::MeshRouteFailureMessage::dest</a>, <a class="el" href="RF22Router_8h_source.html#l00140">RF22Router::RoutedMessageHeader::dest</a>, <a class="el" href="RF22Mesh_8h_source.html#l00130">RF22Mesh::MeshRouteFailureMessage::header</a>, <a class="el" href="RF22Router_8h_source.html#l00151">RF22Router::RoutedMessage::header</a>, <a class="el" href="RF22_8cpp_source.html#l00695">RF22::headerFrom()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00107">RF22Mesh::MeshMessageHeader::msgType</a>, <a class="el" href="RF22Mesh_8cpp_source.html#l00032">sendtoWait()</a>, and <a class="el" href="RF22Router_8h_source.html#l00141">RF22Router::RoutedMessageHeader::source</a>.</p>

<p>Referenced by <a class="el" href="RF22Mesh_8cpp_source.html#l00032">sendtoWait()</a>.</p>

</div>
</div>
<a class="anchor" id="ada9dcba842569c7f126fdb1d085753a5"></a><!-- doxytag: member="RF22Mesh::sendtoWait" ref="ada9dcba842569c7f126fdb1d085753a5" args="(uint8_t *buf, uint8_t len, uint8_t dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF22Mesh::sendtoWait </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a message to the destination node. Initialises the <a class="el" href="classRF22Router.html" title="RF22 subclass for sending addressed, optionally acknowledged datagrams multi-hop...">RF22Router</a> message header (the SOURCE address is set to the address of this node, HOPS to 0) and calls <a class="el" href="classRF22Mesh.html#ae7a3ab2784aaf45ab2d47e5d9ce5b405">route()</a> which looks up in the routing table the next hop to deliver to. If no route is known, initiates route discovery and waits for a reply. Then sends the message to the next hop Then waits for an acknowledgement from the next hop (but not from the destination node (if that is different). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>The application message data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Number of octets in the application message data. 0 is permitted </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest</em>&nbsp;</td><td>The destination node address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result code:<ul>
<li>RF22_ROUTER_ERROR_NONE Message was routed and deliverd to the next hop (not necessarily to the final dest address)</li>
<li>RF22_ROUTER_ERROR_NO_ROUTE There was no route for dest in the local routing table</li>
<li>RF22_ROUTER_ERROR_UNABLE_TO_DELIVER Noyt able to deliver to the next hop (usually because it dod not acknowledge due to being off the air or out of range </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classRF22Router.html#adb03b403f981659ea55e90867741d085">RF22Router</a>.</p>

<p>References <a class="el" href="RF22Mesh_8h_source.html#l00114">RF22Mesh::MeshApplicationMessage::data</a>, <a class="el" href="RF22Mesh_8cpp_source.html#l00049">doArp()</a>, <a class="el" href="RF22Router_8cpp_source.html#l00088">RF22Router::getRouteTo()</a>, <a class="el" href="RF22Mesh_8h_source.html#l00113">RF22Mesh::MeshApplicationMessage::header</a>, <a class="el" href="RF22Mesh_8h_source.html#l00107">RF22Mesh::MeshMessageHeader::msgType</a>, and <a class="el" href="RF22Mesh_8cpp_source.html#l00117">route()</a>.</p>

<p>Referenced by <a class="el" href="RF22Mesh_8cpp_source.html#l00049">doArp()</a>, <a class="el" href="RF22Mesh_8cpp_source.html#l00149">recvfromAck()</a>, and <a class="el" href="RF22Mesh_8cpp_source.html#l00117">route()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="RF22Mesh_8h_source.html">RF22Mesh.h</a></li>
<li>RF22Mesh.cpp</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun Oct 16 19:50:04 2011 for RF22 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
